---
description: Rules for multi-agent and LangGraph development
globs: ["**/agents/**/*.py", "**/orchestrator/**/*.py", "**/workflows/**/*.py", "**/graphs/**/*.py"]
alwaysApply: false
---

# Agent Orchestration Rules

## LangGraph Patterns

### Graph Structure
```python
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver

# Define state schema
class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    current_step: str
    context: dict

# Build graph
graph = StateGraph(AgentState)
graph.add_node("planner", planner_node)
graph.add_node("executor", executor_node)
graph.add_node("validator", validator_node)

# Add edges
graph.add_edge("planner", "executor")
graph.add_conditional_edges("executor", should_continue, {
    "continue": "executor",
    "validate": "validator",
    "end": END
})

# Compile with checkpointer for persistence
checkpointer = MemorySaver()
app = graph.compile(checkpointer=checkpointer)
```

### Human-in-the-Loop
```python
graph.add_node("human_review", human_review_node)
graph.add_conditional_edges("executor", needs_approval, {
    "approved": "continue",
    "needs_review": "human_review"
})
```

## Agent Design Principles

### Single Responsibility
- Each agent has ONE clear role
- Planner: Creates execution plans
- Executor: Runs individual steps
- Validator: Verifies outputs
- Router: Directs to appropriate agent

### State Management
- Use TypedDict for state schema
- Keep state minimal but sufficient
- Use checkpointer for persistence
- Pass only necessary context between nodes

### Error Handling
- Implement retry logic with backoff
- Set max_iterations to prevent infinite loops
- Graceful degradation on failures
- Human escalation for unresolvable issues

## Safety Controls
- Default-deny for tool access
- Validate all tool inputs/outputs
- Log all agent decisions
- Implement step limits (max 50 steps)
- Require approval for destructive actions
